---
typora-root-url: images
typora-copy-images-to: images
---

@[TOC]

# 前言

数据结构中有数据操作过程不好理解，我们可以通过图像和动画来理解，下面是一些图像和动画生成的网站。

![1573284876371](/1573284876371.png)

# 一、数组

## 1.1、**线性表的定义**

**线性表：** 具有n个相同类型元素的有限序列（n>=0）

**常见的线性表有：**

* 数组
* 链表
* 栈
* 队列
* 哈希表（散列表）

## 1.2、数组

**数组：** 是一种顺序存储的线性表，所有元素的内存地址都是连续的。

* 数组作为常用的数据结构，所以很多编程语言都会内置数组。

**代码实现：**

`ArrayList类`

```java
// 动态数组
public class ArrayList<E> {
    // 元素个数
    private int size;

    // 数组
    private E[] elements;

    // 默认容量
    private static final int DEFAULT_CAPACITY = 10;

    // 元素未找到
    private static final int ELEMENT_NOT_FOUND = -1;

    public ArrayList(int capacity) {
        capacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;
        elements = (E[]) new Object[capacity];
    }

    public ArrayList() {
        this(DEFAULT_CAPACITY);
    }

    /**
     * 清空数组全部元素
     */
    public void clear() {
        for (int i = 0; i < size; i++) {
            // 因为使用了泛型，泛型只能存引用类型的对象，Object[]中存取的是对象的地址值
            // 所以清空的时候把每个元素地址值指向的对象释放掉，而不是销毁整个数组，数组可以留下循环利用。
            elements[i] = null;
        }
        size = 0;
    }

    /**
     * 数组中元素的个数
     *
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 数组是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 是否包含某个元素
     *
     * @return
     */
    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    /**
     * 添加元素到末尾
     * 最好时间复杂度:O(1) 没发生扩容情况
     * 最坏时间复杂度:O(n) 扩容情况
     * 平均时间复杂度:O(1)
     * 均摊时间复杂度:
     * @param element
     */
    public void add(E element) {
        add(size, element);
    }

    /**
     * 获取索引index的元素
     * 时间复杂度O(1)
     * @param index
     * @return
     */
    public E get(int index) {
        rangeCheck(index);
        return elements[index];
    }

    /**
     * 修改索引index位置的元素，并返回旧值
     * 时间复杂度：O(1)
     * @param index
     * @param element
     * @return
     */
    public E set(int index, E element) {
        rangeCheck(index);
        E old = elements[index];
        elements[index] = element;
        return old;
    }

    /**
     * 在索引index位置插入一个新的元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     * @param index
     * @param element
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        ensureCapacity(size + 1);
        for (int i = size; i > index; i--) {
            elements[i] = elements[i - 1];
        }
        elements[index] = element;
        size++;
    }

    /**
     * 删除索引index位置的元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     * @param index
     * @return
     */
    public E remove(int index) {
        rangeCheck(index);
        E old = elements[index];
        for (int i = index + 1; i < size; i++) {
            this.elements[i - 1] = this.elements[i];
        }
        elements[--size] = null;
        return old;
    }

    /**
     * 查找元素的索引位置
     * 不存在的元素返回-1
     *
     * @param element
     * @return
     */
    public int indexOf(E element) {
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (elements[i] == null) return i;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(elements[i])) return i;
            }
        }

        return ELEMENT_NOT_FOUND;
    }

    /**
     * 保证容量有capacity
     *
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        // 新容量为旧容量的1.5倍
        // >>1 代表右移1位 可以理解为除以2
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E newElements[] = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
        System.out.println(oldCapacity + " 扩容为 " + newCapacity);
    }

    private void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("Index is " + index + ",But size is " + size);
    }

    private void rangeCheck(int index) {
        if (index < 0 || index >= size) {
            outOfBounds(index);
        }

    }

    private void rangeCheckForAdd(int index) {
        if (index < 0 || index > size) {
            outOfBounds(index);
        }
    }

    /**
     * 打印ArrayList
     * 格式：
     * size = 10,[1,2,3]
     *
     * @return
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("size = " + this.size).append(" ,[");
        for (int i = 0; i < size; i++) {
            if (i != 0) sb.append(",");
            sb.append(elements[i]);
        }
        sb.append("]");
        return sb.toString();
    }
}

```

`ArrayList2类`:增加动态缩容方法

```java
package com.zsd;


// 动态数组
// 添加动态缩容
public class ArrayList2<E> {
    // 元素个数
    private int size;

    // 数组
    private E[] elements;

    // 默认容量
    private static final int DEFAULT_CAPACITY = 10;

    // 元素未找到
    private static final int ELEMENT_NOT_FOUND = -1;

    public ArrayList2(int capacity) {
        capacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;
        elements = (E[]) new Object[capacity];
    }

    public ArrayList2() {
        this(DEFAULT_CAPACITY);
    }

    /**
     * 清空数组全部元素
     */
    public void clear() {
        for (int i = 0; i < size; i++) {
            // 因为使用了泛型，泛型只能存引用类型的对象，Object[]中存取的是对象的地址值
            // 所以清空的时候把每个元素地址值指向的对象释放掉，而不是销毁整个数组，数组可以留下循环利用。
            elements[i] = null;
        }
        size = 0;
    }

    /**
     * 数组中元素的个数
     *
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 数组是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 是否包含某个元素
     *
     * @return
     */
    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    /**
     * 添加元素到末尾
     * 最好时间复杂度:O(1) 没发生扩容情况
     * 最坏时间复杂度:O(n) 扩容情况
     * 平均时间复杂度:O(1)
     * 均摊时间复杂度:
     *
     * @param element
     */
    public void add(E element) {
        add(size, element);
    }

    /**
     * 获取索引index的元素
     * 时间复杂度O(1)
     *
     * @param index
     * @return
     */
    public E get(int index) {
        rangeCheck(index);
        return elements[index];
    }

    /**
     * 修改索引index位置的元素，并返回旧值
     * 时间复杂度：O(1)
     *
     * @param index
     * @param element
     * @return
     */
    public E set(int index, E element) {
        rangeCheck(index);
        E old = elements[index];
        elements[index] = element;
        return old;
    }

    /**
     * 在索引index位置插入一个新的元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     *
     * @param index
     * @param element
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        ensureCapacity(size + 1);
        for (int i = size; i > index; i--) {
            elements[i] = elements[i - 1];
        }
        elements[index] = element;
        size++;
    }

    /**
     * 删除索引index位置的元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     *
     * @param index
     * @return
     */
    public E remove(int index) {
        rangeCheck(index);
        E old = elements[index];
        for (int i = index + 1; i < size; i++) {
            this.elements[i - 1] = this.elements[i];
        }
        elements[--size] = null;
        trim();
        return old;
    }

    /**
     * 查找元素的索引位置
     * 不存在的元素返回-1
     *
     * @param element
     * @return
     */
    public int indexOf(E element) {
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (elements[i] == null) return i;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(elements[i])) return i;
            }
        }

        return ELEMENT_NOT_FOUND;
    }

    /**
     * 保证容量有capacity
     *
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        // 新容量为旧容量的1.5倍
        // >>1 代表右移1位 可以理解为除以2
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E newElements[] = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
        System.out.println(oldCapacity + " 扩容为 " + newCapacity);
    }

    /**
     * 动态缩容
     */
    private void trim() {
        int capacity = elements.length;
        // 容量变为原来的一半
        int newCapacity = capacity >> 1;
        // 容量剩的不多
        if (size >= newCapacity || capacity <= DEFAULT_CAPACITY) return;
        // 容量剩的很多
        E newElements[] = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
        System.out.println(capacity + " 缩容为 " + newCapacity);
    }

    private void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("Index is " + index + ",But size is " + size);
    }

    private void rangeCheck(int index) {
        if (index < 0 || index >= size) {
            outOfBounds(index);
        }

    }

    private void rangeCheckForAdd(int index) {
        if (index < 0 || index > size) {
            outOfBounds(index);
        }
    }

    /**
     * 打印ArrayList
     * 格式：
     * size = 10,[1,2,3]
     *
     * @return
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("size = " + this.size).append(" ,[");
        for (int i = 0; i < size; i++) {
            if (i != 0) sb.append(",");
            sb.append(elements[i]);
        }
        sb.append("]");
        return sb.toString();
    }
}


```





Person类`

```java
public class Person {
    private int age;
    private String name;


    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) return false;
        if (obj instanceof Person) {
            Person p = (Person) obj;
            return this.age == p.age && this.name == p.name;
        }
        return false;
    }


    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("Person-finalize");
    }
}

```

`Main类`：测试类

```java
public class Main {
    public static void main(String[] args) {
        ArrayList<Person> list = new ArrayList<>();
        list.add(new Person(15,"boy"));
        list.add(null);
        list.add(new Person(15,"coco"));
        list.add(null);
        list.add(new Person(15,"jack"));
        System.out.println(list);

        System.out.println(list.indexOf(null));

    }
}
```





# 二、链表

## 2.1、链表的定义

**链表：** 是一种链式存储的线性表，所有元素存储的内存地址不一定连续。



# 三 、栈

# 四、队列  

## 4.1、队列的定义

**队列：** 是一种特殊的线性表，只能在头尾两端进行操作。

* 队尾(rear)：只能在队尾添加元素，一般称为入队。
* 队头(front)：只能从队头移除元素，一般称为出队。
* 先进先出的原则，First In First Out，FIFO。



# 五、树

## 5.1 树的定义与性质

**树：** 树是有至少0个节点构成的集合。0个节点的树称为空树。1个节点的树，只有1个根节点。

**节点的度： ** 子树的个数。

**树的度：** 所有节点的度中的最大值。

**叶子节点：** 度为0的节点。

**非叶子节点：** 度不为0的节点。

**层数：** 根节点为第1层，根节点的子节点为第2层。(有些书籍定义根节点为第0层)

**节点的深度：** 从根节点到当前节点的唯一路径的节点总数。

**节点的高度：** 从根节点到最远叶子节点的节点总数。

**树的深度：** 所有节点深度中的最大值。

**树的高度：** 所有节点中深度的最大值。

**ps：** 树的深度等于树的高。

**有序树：** 树中的任意一个节点的个孩子节点有严格排列次序的树。

**无序树：** 树中任意一个节点的各孩子节点之间的次序无紧要的树。

## 5.2、二叉树的定义和性质

**二叉树：** 是由n（n>=0）个有限的节点构成的集合。每个节点的度最大为2。

**性质1：** 非空二叉树的第i层，最多有2<sup>i-1</sup>个节点（i>=1）。

**性质2：** 在高度为h的二叉树最多有2<sup>h-1</sup>个节点（h>=1）。

**性质3：** 对于一棵非空的二叉树，如果节点个数为n<sub>0</sub>,度为2的节点数为n<sub>2</sub>,则有n<sub>0</sub> = n<sub>2</sub>+1。

假设度为1的节点个数为n<sub>1</sub>，那么二叉树的节点总数为n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>

另外，二叉树中除了根节点，每个节点都有指向它的边，二叉树的总边数为T=n-1。

从二叉树的结构可以知道，二叉树的边数是由度为1和度为2的节点发出的，每个度为1的节点发出一条边数，每个度为2的节点发出两条边，所以有：T=n<sub>1</sub>+2n<sub>2</sub>

则有T=n<sub>1</sub>+2n<sub>2</sub> =n-1=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>-1,得出n<sub>0</sub> = n<sub>2</sub>+1。

**满二叉树：** 所有节点的度要么为0，要么为2，且所有叶子节点都在最后一层。

**性质1：** 假设二叉树的高度为h（h>=1），那么

* 第i层的节点数量：2<sup>i-1</sup>

* 叶子节点数量：2<sup>h-1</sup>	

* 总节点数量：n=2<sup>h</sup>-1

**ps：** 在同样高度的二叉树中，满二叉树的叶子节点数量最多，总节点数量最多。

**完全二叉树：** 如果一棵具有n个节点的二叉树的结构与满二叉树的前n个节点的结构相同。

**性质1：** 度为1的节点只有左子树。

**性质2：** 度为1的节点要么是1个，要么是0个。

**性质3：** 同样节点数量的二叉树，完全二叉树的高度是最小的。

**性质4：** 假设完全二叉树的高度为h（h>=1）,那么

* 至少有2<sup>h-1</sup>个节点（2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>+..+2<sup>h-2</sup>+1）。

* 至多有2<sup>h-1</sup>个节点(相当于满二叉树)。

* 总节点数量为n，高度h = floor(log<sub>2</sub>n)+1（floor是向下取整函数）。

**性质5：** 一棵有n个节点的完全二叉树（n>0），从上到下，从左到右对节点从1开始编号，对第i个节点，

* 如果i=1，它是根节点
* 如果i>1，它的父节点编号为floor(i/2)
* 如果2i<=n，它的左子节点编号为2i
* 如果2i>n，它无左子节点
* 如果2i+1<=n，它的有子节点编号为2i+1
* 如果2i+1>n，它无右子节点

**性质6：** 一棵有n个节点的完全二叉树（n>0），从上到下，从左到右对节点从0开始编号，对第i个节点，

* 如果i=0，它是根节点
* 如果i>0，它的父节点编号为floor((i-1)/2)
* 如果2i+1<=n-1，它的左子节点编号为2i+1
* 如果2i+1>n-1，它无左子节点
* 如果2i+2<=n-1，它的有子节点编号为2i+2
* 如果2i+2>n-1，它无右子节点

**ps：** 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。

## 5.3、二叉搜索树(Binary Search Tree)

**二叉搜索树：** 是二叉树的一种，是应用非常广泛的二叉树，英文简称为BST。

* 又被称为：二叉查找树，二叉排序树。

* 任意一个节点的值都大于其左子树所有节点的值。
* 任意一个节点的值都小于其右子树所有节点的值。
* 二叉搜索树可以大大提高搜索数据的效率。

![1573097012470](/1573097012470.png)

**代码实现：**

`Person类`

```java
public class Person implements Comparable<Person> {
    private int age;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person(int age) {
        this.age = age;
    }

    @Override
    public int compareTo(Person e) {
        return this.age - e.age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                '}';
    }
}
```

`BinarySearchTree类`：二叉搜索树

```java
import java.util.Comparator;

public class BinarySearchTree<E> implements BinaryTreeInfo {
    private int size;
    private Node<E> root;
    private Comparator<E> comparator;

    public BinarySearchTree() {
        this(null);
    }

    public BinarySearchTree(Comparator<E> comparator) {
        this.comparator = comparator;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public void clear() {

    }

    public void add(E element) {
        elementNotNullCheck(element);
        // 添加第一个节点 即根节点
        if (root == null) {
            root = new Node<>(element, null);
            size++;
        }
        // 添加的不是第一个节点
        // 找到父节点
        Node<E> parent = null;
        Node<E> node = root;
        // 把方向存起来
        int cmp = 0;
        while (node != null) {
            cmp = compare(element, node.element);
            parent = node;
            if (cmp > 0) {
                node = node.right;
            } else if (cmp < 0) {
                node = node.left;
            } else {
                // 相等
                // 新的节点覆盖旧的节点
                node.element = element;
                return;
            }
        }

        // 看看要插入到父节点的左边还是右边
        Node<E> newNode = new Node<>(element, parent);
        if (cmp > 0) {
            parent.right = newNode;
        } else {
            parent.left = newNode;
        }
        size++;
    }

    public void remove(E element) {

    }

    public boolean contains(E element) {
        return false;
    }

    public void elementNotNullCheck(E element) {
        if (element == null) {
            throw new IllegalArgumentException("element must not be null");
        }
    }


    /**
     * @return 如果e1等于e2，返回0；如果e1大于e2，返回值大于0；如果e1小于e2，返回值小于0；
     */
    private int compare(E e1, E e2) {
        if (comparator != null) {
            return comparator.compare(e1, e2);
        }
        return ((Comparable<E>) e1).compareTo(e2);
    }

    @Override
    public Object root() {
        return root;
    }

    @Override
    public Object left(Object node) {
        return ((Node<E>) node).left;
    }

    @Override
    public Object right(Object node) {
        return ((Node<E>) node).right;
    }

    @Override
    public Object string(Object node) {
        return ((Node<E>) node).element;
    }

    private static class Node<E> {
        E element;
        Node<E> left;
        Node<E> right;
        Node<E> parent;

        public Node(E element, Node<E> parent) {
            this.element = element;
            this.parent = parent;
        }
    }
}
```



`Main类 `：测试类

```java
import java.util.Comparator;

public class Main {
    private static class PersonComparator implements Comparator<Person> {

        @Override
        public int compare(Person e1, Person e2) {
            return e1.getAge() - e2.getAge();
        }
    }

    private static class PersonComparator2 implements Comparator<Person> {

        @Override
        public int compare(Person e1, Person e2) {
            return e2.getAge() - e1.getAge();
        }
    }

    // 测试Integer数组的二叉搜索树
    private static void test1(){
        BinarySearchTree<Integer> bst1 = new BinarySearchTree();
        Integer data[] = new Integer[]{7,4,9,2,5,8,11,3,12,1};
        for (int i = 0; i < data.length; i++) {
            bst1.add(data[i]);
        }

        BinaryTrees.print(bst1);
    }

    // 测试自定义的比较器二叉搜索树
    private static void test2(){
        Integer data[] = new Integer[]{7,4,9,2,5,8,11,3,12,1};
        // 传入比较器比较
        BinarySearchTree<Person> bst1 = new BinarySearchTree(new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o2.getAge()-o1.getAge();
            }
        });

        for (int i = 0; i < data.length; i++) {
            bst1.add(new Person(data[i]));
        }
        BinaryTrees.println(bst1);
    }

    // 测试写入文件
    private static void test3(){
        BinarySearchTree<Integer> bst1 = new BinarySearchTree();
        Integer data[] = new Integer[]{7,4,9,2,5,8,11,3,12,1};
        for (int i = 0; i < data.length; i++) {
            bst1.add(data[i]);
        }
        Files.writeToFile("./tree.txt",BinaryTrees.printString(bst1));
    }

    // 测试比较值相等，就覆盖
    private static void test4(){
        BinarySearchTree<Person> bst1 = new BinarySearchTree();
        bst1.add(new Person(12,"zhangsan"));
        bst1.add(new Person(15,"lisi"));
        bst1.add(new Person(18,"wangwu"));
        bst1.add(new Person(15,"zhaoliu"));
        bst1.add(new Person(10,"wangba"));
        BinaryTrees.println(bst1);
    }

    public static void main(String[] args) {
        test1();
        System.out.println();
        test2();
        test3();
        System.out.println();
        test4();
    }
}
```

 

`输出结果`

![1573289114118](/1573289114118.png)



![1573285446138](/1573285446138.png)

## 5.4、二叉树的遍历

根据根节点访问顺序的不同，二叉树的常见遍历方式有4种：

* 前序遍历(Preorder Traversal)：先访问根节点、再访问左子树，再访问右子树。下图二叉树前序遍历的顺序为：7、4、2、1、3 、5 、9、8、11、10、12 

**代码实现：**

```java
// 前序遍历的外部访问
public void preorderTraversal() {
    preorderTraversal(root);
}

// 前序遍历
private void preorderTraversal(Node<E> node) {
    if (node == null) return;
    // 打印当前访问的节点
    System.out.println(node.element);
    // 遍历左子树
    preorderTraversal(node.left);
    // 遍历右子树
    preorderTraversal(node.right);
}
```



* 中序遍历(Inorder Traversal)：中序遍历因为只要第二个访问根节点就行，所有就有先访问左子树还是右子树两种。

  1. 先访问左子树，再访问根节点，再访问有右子树。下图二叉树中序遍历的顺序为：1、2、3、4、5、7、8、9、10、11、12

  2. 先访问右子树，再访问根节点，再访问有左子树。下图二叉树中序遍历的顺序为：12、11、10、9、8、7、5、4、3、2、1

  3. 根据前两点可以知道，二叉搜索树的遍历的结果是升序或者降序的。

**代码实现：**

```java
// 中序遍历的外部访问
public void inorderTraversal(){
    inorderTraversal(root);
}

// 中序遍历
private void inorderTraversal(Node<E> node) {
    if (node == null) return;
    // 遍历左子树
    inorderTraversal(node.left);
    // 打印当前访问的节点
    System.out.println(node.element);
    // 遍历右子树
    inorderTraversal(node.right);
}
```



* 后序遍历(Postorder Traversal)：先访问左子树，再访问右子树，再访问有根节点。下图二叉树后序遍历的顺序为：1、3、2、5、4、8、10、12、11、9、7

**代码实现：**

```java
// 后序遍历的外部访问
public void postTraversal(){
    postTraversal(root);
}

// 后序遍历
private void postTraversal(Node<E> node) {
    if (node == null) return;
    // 遍历左子树
    postTraversal(node.left);
    // 遍历右子树
    postTraversal(node.right);
    // 打印当前访问的节点
    System.out.println(node.element);
}
```



* 层序遍历(Level Order Traversal)：从上到下，从左到右依次访问每一个节点。

**代码实现：**



![1573289991207](/1573289991207.png)



# 六、图













