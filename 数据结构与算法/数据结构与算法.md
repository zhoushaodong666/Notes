---
typora-root-url: images
typora-copy-images-to: images
---

@[TOC]

# 前言

数据结构中有数据操作过程不好理解，我们可以通过图像和动画来理解，下面是一些图像和动画生成的网站。

![1573284876371](/1573284876371.png)

# 一、数组

## 1.1、**线性表的定义**

**线性表：** 具有n个相同类型元素的有限序列（n>=0）

**常见的线性表有：**

* 数组
* 链表
* 栈
* 队列
* 哈希表（散列表）

## 1.2、数组

**数组：** 是一种顺序存储的线性表，所有元素的内存地址都是连续的。

* 数组作为常用的数据结构，所以很多编程语言都会内置数组。

**代码实现：**

`ArrayList类`

```java
// 动态数组
public class ArrayList<E> {
    // 元素个数
    private int size;

    // 数组
    private E[] elements;

    // 默认容量
    private static final int DEFAULT_CAPACITY = 10;

    // 元素未找到
    private static final int ELEMENT_NOT_FOUND = -1;

    public ArrayList(int capacity) {
        capacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;
        elements = (E[]) new Object[capacity];
    }

    public ArrayList() {
        this(DEFAULT_CAPACITY);
    }

    /**
     * 清空数组全部元素
     */
    public void clear() {
        for (int i = 0; i < size; i++) {
            // 因为使用了泛型，泛型只能存引用类型的对象，Object[]中存取的是对象的地址值
            // 所以清空的时候把每个元素地址值指向的对象释放掉，而不是销毁整个数组，数组可以留下循环利用。
            elements[i] = null;
        }
        size = 0;
    }

    /**
     * 数组中元素的个数
     *
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 数组是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 是否包含某个元素
     *
     * @return
     */
    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    /**
     * 添加元素到末尾
     * 最好时间复杂度:O(1) 没发生扩容情况
     * 最坏时间复杂度:O(n) 扩容情况
     * 平均时间复杂度:O(1)
     * 均摊时间复杂度:
     * @param element
     */
    public void add(E element) {
        add(size, element);
    }

    /**
     * 获取索引index的元素
     * 时间复杂度O(1)
     * @param index
     * @return
     */
    public E get(int index) {
        rangeCheck(index);
        return elements[index];
    }

    /**
     * 修改索引index位置的元素，并返回旧值
     * 时间复杂度：O(1)
     * @param index
     * @param element
     * @return
     */
    public E set(int index, E element) {
        rangeCheck(index);
        E old = elements[index];
        elements[index] = element;
        return old;
    }

    /**
     * 在索引index位置插入一个新的元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     * @param index
     * @param element
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        ensureCapacity(size + 1);
        for (int i = size; i > index; i--) {
            elements[i] = elements[i - 1];
        }
        elements[index] = element;
        size++;
    }

    /**
     * 删除索引index位置的元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     * @param index
     * @return
     */
    public E remove(int index) {
        rangeCheck(index);
        E old = elements[index];
        for (int i = index + 1; i < size; i++) {
            this.elements[i - 1] = this.elements[i];
        }
        elements[--size] = null;
        return old;
    }

    /**
     * 查找元素的索引位置
     * 不存在的元素返回-1
     *
     * @param element
     * @return
     */
    public int indexOf(E element) {
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (elements[i] == null) return i;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(elements[i])) return i;
            }
        }

        return ELEMENT_NOT_FOUND;
    }

    /**
     * 保证容量有capacity
     *
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        // 新容量为旧容量的1.5倍
        // >>1 代表右移1位 可以理解为除以2
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E newElements[] = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
        System.out.println(oldCapacity + " 扩容为 " + newCapacity);
    }

    private void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("Index is " + index + ",But size is " + size);
    }

    private void rangeCheck(int index) {
        if (index < 0 || index >= size) {
            outOfBounds(index);
        }

    }

    private void rangeCheckForAdd(int index) {
        if (index < 0 || index > size) {
            outOfBounds(index);
        }
    }

    /**
     * 打印ArrayList
     * 格式：
     * size = 10,[1,2,3]
     *
     * @return
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("size = " + this.size).append(" ,[");
        for (int i = 0; i < size; i++) {
            if (i != 0) sb.append(",");
            sb.append(elements[i]);
        }
        sb.append("]");
        return sb.toString();
    }
}

```

`ArrayList2类`:增加动态缩容方法

```java
// 动态数组
// 添加动态缩容
public class ArrayList2<E> {
    // 元素个数
    private int size;

    // 数组
    private E[] elements;

    // 默认容量
    private static final int DEFAULT_CAPACITY = 10;

    // 元素未找到
    private static final int ELEMENT_NOT_FOUND = -1;

    public ArrayList2(int capacity) {
        capacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;
        elements = (E[]) new Object[capacity];
    }

    public ArrayList2() {
        this(DEFAULT_CAPACITY);
    }

    /**
     * 清空数组全部元素
     */
    public void clear() {
        for (int i = 0; i < size; i++) {
            // 因为使用了泛型，泛型只能存引用类型的对象，Object[]中存取的是对象的地址值
            // 所以清空的时候把每个元素地址值指向的对象释放掉，而不是销毁整个数组，数组可以留下循环利用。
            elements[i] = null;
        }
        size = 0;
        // 缩容
        if (elements != null && elements.length > DEFAULT_CAPACITY) {
            elements = (E[]) new Object[DEFAULT_CAPACITY];
        }
    }

    /**
     * 数组中元素的个数
     *
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 数组是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 是否包含某个元素
     *
     * @return
     */
    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    /**
     * 添加元素到末尾
     * 最好时间复杂度:O(1) 没发生扩容情况
     * 最坏时间复杂度:O(n) 扩容情况
     * 平均时间复杂度:O(1)
     * 均摊时间复杂度:
     *
     * @param element
     */
    public void add(E element) {
        add(size, element);
    }

    /**
     * 获取索引index的元素
     * 时间复杂度O(1)
     *
     * @param index
     * @return
     */
    public E get(int index) {
        rangeCheck(index);
        return elements[index];
    }

    /**
     * 修改索引index位置的元素，并返回旧值
     * 时间复杂度：O(1)
     *
     * @param index
     * @param element
     * @return
     */
    public E set(int index, E element) {
        rangeCheck(index);
        E old = elements[index];
        elements[index] = element;
        return old;
    }

    /**
     * 在索引index位置插入一个新的元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     *
     * @param index
     * @param element
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        ensureCapacity(size + 1);
        for (int i = size; i > index; i--) {
            elements[i] = elements[i - 1];
        }
        elements[index] = element;
        size++;
    }

    /**
     * 删除索引index位置的元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     *
     * @param index
     * @return
     */
    public E remove(int index) {
        rangeCheck(index);
        E old = elements[index];
        for (int i = index + 1; i < size; i++) {
            this.elements[i - 1] = this.elements[i];
        }
        elements[--size] = null;
        trim();
        return old;
    }

    /**
     * 查找元素的索引位置
     * 不存在的元素返回-1
     *
     * @param element
     * @return
     */
    public int indexOf(E element) {
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (elements[i] == null) return i;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(elements[i])) return i;
            }
        }

        return ELEMENT_NOT_FOUND;
    }

    /**
     * 保证容量有capacity
     *
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        // 新容量为旧容量的1.5倍
        // >>1 代表右移1位 可以理解为除以2
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E newElements[] = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
        System.out.println(oldCapacity + " 扩容为 " + newCapacity);
    }

    /**
     * 动态缩容
     */
    private void trim() {
        int capacity = elements.length;
        // 容量变为原来的一半
        int newCapacity = capacity >> 1;
        // 容量剩的不多
        if (size >= newCapacity || capacity <= DEFAULT_CAPACITY) return;
        // 容量剩的很多
        E newElements[] = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
        System.out.println(capacity + " 缩容为 " + newCapacity);
    }

    private void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("Index is " + index + ",But size is " + size);
    }

    private void rangeCheck(int index) {
        if (index < 0 || index >= size) {
            outOfBounds(index);
        }

    }

    private void rangeCheckForAdd(int index) {
        if (index < 0 || index > size) {
            outOfBounds(index);
        }
    }

    /**
     * 打印ArrayList
     * 格式：
     * size = 10,[1,2,3]
     *
     * @return
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("size = " + this.size).append(" ,[");
        for (int i = 0; i < size; i++) {
            if (i != 0) sb.append(",");
            sb.append(elements[i]);
        }
        sb.append("]");
        return sb.toString();
    }
}

```





Person类`

```java
public class Person {
    private int age;
    private String name;


    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) return false;
        if (obj instanceof Person) {
            Person p = (Person) obj;
            return this.age == p.age && this.name == p.name;
        }
        return false;
    }


    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("Person-finalize");
    }
}

```

`Main类`：测试类

```java
public class Main {
    public static void main(String[] args) {
        ArrayList<Person> list = new ArrayList<>();
        list.add(new Person(15,"boy"));
        list.add(null);
        list.add(new Person(15,"coco"));
        list.add(null);
        list.add(new Person(15,"jack"));
        System.out.println(list);

        System.out.println(list.indexOf(null));

    }
}
```





# 二、链表

## 2.1、链表的定义

**链表：** 是一种链式存储的线性表，所有元素存储的内存地址不一定连续。

## 2.2、单链表

**单链表：** 每个节点由两部分组成，一个就是存放数据的data数据域，另一个是存放指向下个后继节点的next指针域。除了尾部的节点，每个节点都有一个后继节点。

**代码实现：** 

`List接口`：抽取线性表的共性方法

```java
public interface List<E> {
    // 元素未找到
    static final int ELEMENT_NOT_FOUND = -1;

    /**
     * 清空数组全部元素
     */
    public void clear();

    /**
     * 数组中元素的个数
     *
     * @return
     */
    public int size();

    /**
     * 数组是否为空
     *
     * @return
     */
    public boolean isEmpty();

    /**
     * 是否包含某个元素
     *
     * @return
     */
    public boolean contains(E element);

    /**
     * 添加元素到末尾
     *
     * @param element
     */
    public void add(E element);

    /**
     * 获取索引index的元素
     *
     * @param index
     * @return
     */
    public E get(int index);

    /**
     * 修改索引index位置的元素，并返回旧值
     *
     * @param index
     * @param element
     * @return
     */
    public E set(int index, E element);

    /**
     * 在索引index位置插入一个新的元素
     *
     * @param index
     * @param element
     */
    public void add(int index, E element);

    /**
     * 删除索引index位置的元素
     *
     * @param index
     * @return
     */
    public E remove(int index);

    /**
     * 查找元素的索引位置
     * 不存在的元素返回-1
     *
     * @param element
     * @return
     */
    public int indexOf(E element);

}

```

`AbstractList抽象类`：抽取出子类中可以共用的方法

```java
public abstract class AbstractList<E> implements List<E> {
    // 元素个数
    protected int size;

    /**
     * 数组中元素的个数
     *
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 数组是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 是否包含某个元素
     *
     * @return
     */
    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    /**
     * 添加元素到末尾
     *
     * @param element
     */
    public void add(E element) {
        add(size, element);
    }

    protected void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("Index is " + index + ",But size is " + size);
    }

    protected void rangeCheck(int index) {
        if (index < 0 || index >= size) {
            outOfBounds(index);
        }

    }

    protected void rangeCheckForAdd(int index) {
        if (index < 0 || index > size) {
            outOfBounds(index);
        }
    }

}

```

`SingleLinkedList类`：单链表的实现(无虚拟头节点)

```java
package com.zsd.single;

import com.zsd.AbstractList;

public class SingleLinkedList<E> extends AbstractList<E> {
    private Node<E> first;

    @Override
    public void clear() {
        size = 0;
        first = null;
    }


    /**
     * 根据索引获取元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     *
     * @param index
     * @return
     */
    @Override
    public E get(int index) {
        return node(index).element;
    }

    /**
     * 修改元素值
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 均时间复杂度：O(n)
     *
     * @param index
     * @param element
     * @return
     */
    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    /**
     * 在index位置添加元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     *
     * @param index
     * @param element
     */
    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        if (index == 0) {
            first = new Node<>(element, first);
        } else {
            Node<E> prev = node(index - 1);
            prev.next = new Node<>(element, prev.next);
        }
        size++;
    }

    /**
     * 从index位置移除元素
     * 最好时间复杂度：O(1)
     * 最坏时间复杂度：O(n)
     * 平均时间复杂度：O(n)
     *
     * @param index
     * @return
     */
    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> node = first;
        if (index == 0) {
            first = first.next;
        } else {
            Node<E> prev = node(index - 1);
            // 保存旧节点
            node = prev.next;
            prev.next = node.next;
        }
        size--;
        return node.element;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }

        return ELEMENT_NOT_FOUND;
    }

    /**
     * 获取index位置的节点
     *
     * @param index
     * @return
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        Node<E> node = first;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("size = " + this.size).append(" ,[");
        Node<E> node = first;
        for (int i = 0; i < size; i++) {
            if (i != 0) sb.append(",");
            sb.append(node.element);
            node = node.next;
        }
        sb.append("]");
        return sb.toString();
    }
}
```

`SingleLinkedList2类`：单链表的实现(带虚拟头节点)

```java
package com.zsd.single;

import com.zsd.AbstractList;

/**
 * 增加一个虚拟头结点
 * 统一所有节点的处理逻辑，使代码更精简
 *
 
 */
public class SingleLinkedList2<E> extends AbstractList<E> {
    private Node<E> first;

    public SingleLinkedList2() {
        first = new Node<E>(null, null);
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
    }


    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        Node<E> prev = index == 0 ? first : node(index - 1);
        prev.next = new Node<>(element, prev.next);
74
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);

        Node<E> prev = index == 0 ? first : node(index - 1);
        // 保存旧节点
        Node<E> node = prev.next;
        prev.next = node.next;

        size--;
        return node.element;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }

        return ELEMENT_NOT_FOUND;
    }

    /**
     * 获取index位置的节点
     *
     * @param index
     * @return
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        Node<E> node = first.next;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("size = " + this.size).append(" ,[");
        Node<E> node = first.next;
        for (int i = 0; i < size; i++) {
            if (i != 0) sb.append(",");
            sb.append(node.element);
            node = node.next;
        }
        sb.append("]");
        return sb.toString();
    }
}

```

## 2.3、单向循环链表

**单向循环链表：** 单向循环链表是在单向链表的基础做点小修改，就是最后一个节点的next指针指向首节点，如果只有一个节点，那就指向自身。

**代码实现：**

`CircleSingleLinkedList类`

```java
package com.zsd.circle;

import com.zsd.AbstractList;

// 单向循环链表
public class SingleCircleLinkedList<E> extends AbstractList<E> {
    private Node<E> first;

    @Override
    public void clear() {
        size = 0;
        first = null;
    }


    /**
     * 根据索引获取元素
     *
     * @param index
     * @return
     */
    @Override
    public E get(int index) {
        return node(index).element;
    }

    /**
     * 修改元素值
     *
     * @param index
     * @param element
     * @return
     */
    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    /**
     * 在index位置添加元素
     *
     * @param index
     * @param element
     */
    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        if (index == 0) {
            Node<E> newFirst = new Node<>(element, first);
            // 拿到最后一个节点
            Node<E> last = (size == 0) ? newFirst : node(size - 1);
            last.next = newFirst;
            first = newFirst;
        } else {
            Node<E> prev = node(index - 1);
            prev.next = new Node<>(element, prev.next);
        }
        size++;
    }

    /**
     * 从index位置移除元素
     *
     * @param index
     * @return
     */
    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> node = first;
        if (index == 0) {
            if (size == 1) {
                first = null;
            } else {
                Node<E> last = node(size - 1);
                first = first.next;
                last.next = first;
            }

        } else {
            Node<E> prev = node(index - 1);
            // 保存旧节点
            node = prev.next;
            prev.next = node.next;
        }
        size--;
        return node.element;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }

        return ELEMENT_NOT_FOUND;
    }

    /**
     * 获取index位置的节点
     *
     * @param index
     * @return
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        Node<E> node = first;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("size = " + this.size).append(" ,[");
        Node<E> node = first;
        for (int i = 0; i < size; i++) {
            if (i != 0) sb.append(",");
            sb.append(node.element);
            node = node.next;
        }
        sb.append("]");
        return sb.toString();
    }
}

```



## 2.4、双向链表

**双向链表：** 它的每个数据节点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个节点开始，都可以很方便地访问它的前驱节点和后继节点。

`LinkedList类`：双向链表的实现

```java
package com.zsd;

// 双向链表
public class LinkedList<E> extends AbstractList<E> {
    private Node<E> first;
    private Node<E> last;

    // 定义节点
    private static class Node<E> {
        E element;
        Node<E> prev;
        Node<E> next;


        public Node(Node<E> prev, E element, Node<E> next) {
            this.prev = prev;
            this.element = element;
            this.next = next;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            if (prev != null) {
                sb.append(prev.element);
            } else {
                sb.append("null");
            }
            sb.append("_" + element + "_");
            if (next != null) {
                sb.append(next.element);
            } else {
                sb.append("null");
            }
            return sb.toString();
        }
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
        last = null;
    }


    /**
     * 根据索引获取元素
     *
     * @param index
     * @return
     */
    @Override
    public E get(int index) {
        return node(index).element;
    }

    /**
     * 修改元素值
     *
     * @param index
     * @param element
     * @return
     */
    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    /**
     * 在index位置添加元素
     *
     * @param index
     * @param element
     */
    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        // 末尾添加元素
        if (size == index) {
            Node<E> oldLast = last;
            last = new Node<>(oldLast, element, null);
            if (oldLast == null) {
                // 这是链表添加的第一个节点
                first = last;
            } else {
                oldLast.next = last;
            }

        } else {
            Node<E> next = node(index);
            Node<E> prev = next.prev;
            // 新节点已经把自身的prev和next指针指向正确的节点了
            Node<E> node = new Node<>(prev, element, next);
            // 还剩后一个节点的prev和前一个节点的next未指向
            next.prev = node;
            if (prev == null) {
                // index为0的情况
                first = node;
            } else {
                prev.next = node;
            }
        }


        size++;
    }

    /**
     * 从index位置移除元素
     *
     * @param index
     * @return
     */
    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> node = node(index);
        Node<E> prev = node.prev;
        Node<E> next = node.next;

        // index为0
        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
        }

        // index为size-1
        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
        }
        size--;
        return node.element;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }

        return ELEMENT_NOT_FOUND;
    }

    /**
     * 获取index位置的节点
     *
     * @param index
     * @return
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        // 节点在左边区域
        if (index < size >> 1) {
            Node<E> node = first;
            for (int i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        } else {
            // 节点在右边区域
            Node<E> node = last;
            for (int i = size - 1; i > index; i--) {
                node = node.prev;
            }
            return node;
        }
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("size = " + this.size).append(" ,[");
        Node<E> node = first;
        for (int i = 0; i < size; i++) {
            if (i != 0) sb.append(",");
            sb.append(node);
            node = node.next;
        }
        sb.append("]");
        return sb.toString();
    }
}

```

## 2.5、双向循环链表

**双向循环链表：** 是在双向链表的基础上增加一个last指针指向最后一个节点。第一个节点的prev指针要指向最后一个节点，最后一个节点的next指针要指向第一个节点。

**代码实现：**

`CircleLinkedList类`：双向循环链表的实现

```java
package com.zsd.circle;

import com.zsd.AbstractList;

// 双向链表
public class CircleLinkedList<E> extends AbstractList<E> {
    private Node<E> first;
    private Node<E> last;
    private Node<E> current;

    // 定义节点
    private static class Node<E> {
        E element;
        Node<E> prev;
        Node<E> next;


        public Node(Node<E> prev, E element, Node<E> next) {
            this.prev = prev;
            this.element = element;
            this.next = next;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            if (prev != null) {
                sb.append(prev.element);
            } else {
                sb.append("null");
            }
            sb.append("_" + element + "_");
            if (next != null) {
                sb.append(next.element);
            } else {
                sb.append("null");
            }
            return sb.toString();
        }
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
        last = null;
    }


    /**
     * 根据索引获取元素
     *
     * @param index
     * @return
     */
    @Override
    public E get(int index) {
        return node(index).element;
    }

    /**
     * 修改元素值
     *
     * @param index
     * @param element
     * @return
     */
    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    /**
     * 在index位置添加元素
     *
     * @param index
     * @param element
     */
    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        // 末尾添加元素
        if (size == index) {
            Node<E> oldLast = last;
            last = new Node<>(oldLast, element, first);
            if (oldLast == null) {
                // 这是链表添加的第一个节点
                first = last;
                first.prev = first;
                first.next = first;
            } else {
                oldLast.next = last;
                first.prev = last;
            }

        } else {
            Node<E> next = node(index);
            Node<E> prev = next.prev;

            // 新节点已经把自身的prev和next指针指向正确的节点了
            Node<E> node = new Node<>(prev, element, next);
            // 还剩后一个节点的prev和前一个节点的next未指向
            next.prev = node;
            prev.next = node;

            if (next == first) { // index==0
                first = node;
            }
        }

        size++;
    }


    // 移除current节点 并把current指向下一个节点
    public E remove() {
        if (current == null) return null;
        Node<E> next = current.next;
        E element = remove(current);
        if (size == 0) {
            current = null;
        } else {
            current = next;
        }
        return element;
    }

    /**
     * 从index位置移除元素
     *
     * @param index
     * @return
     */
    @Override
    public E remove(int index) {
        rangeCheck(index);
        return remove(node(index));
    }

    /**
     * 删除指定节点
     *
     * @param node
     * @return
     */
    private E remove(Node<E> node) {
        if (size == 1) {
            first = last = null;
        } else {
            Node<E> prev = node.prev;
            Node<E> next = node.next;
            prev.next = next;
            next.prev = prev;
            // index==0
            if (node == first) {
                first = next;
            }

            // index==size-1
            if (node == last) {
                last = prev;
            }
        }

        size--;
        return node.element;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (element.equals(node.element)) return i;
                node = node.next;
            }
        }

        return ELEMENT_NOT_FOUND;
    }

    /**
     * 获取index位置的节点
     *
     * @param index
     * @return
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        // 节点在左边区域
        if (index < size >> 1) {
            Node<E> node = first;
            for (int i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        } else {
            // 节点在右边区域
            Node<E> node = last;
            for (int i = size - 1; i > index; i--) {
                node = node.prev;
            }
            return node;
        }
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("size = " + this.size).append(" ,[");
        Node<E> node = first;
        for (int i = 0; i < size; i++) {
            if (i != 0) sb.append(",");
            sb.append(node);
            node = node.next;
        }
        sb.append("]");
        return sb.toString();
    }

    // 重置current指向first
    public void reset() {
        current = first;
    }

    public E next() {
        if (current == null) return null;
        current = current.next;
        return current.element;
    }
}

```



## 2.6、双向链表VS动态数组

**双向链表：** 开辟、销毁内存空间的次数相对较多，但不会造成内存空间的浪费。

**动态数组：**开辟、销毁内存空间的次数相对较少，但可能造成内存空间的浪费(可以通过缩容解决)。

* 如果频繁在**尾部**进行**添加**、**删除**操作，动态数组、双向链表均可选择
* 如果频繁在**头部**进行**添加**、**删除**操作，建议选择使用双向链表
* 如果频繁的(**在任意位置**)**添加**、**删除**操作，建议选择使用双向链表。
* 如果有频繁的**查询**操作(随机访问),建议选择使用动态数组

## 2.7、LinkedList源码分析

1. 官方的clear()方法和我们实现的相比，多了一个遍历双线链表，删除节点之间的指针联系，是因为官方的还双向链表还实现了迭代器Iterator,使用clear()之后，双向链表中的节点还可能被Iterator指向，所以做了遍历删除节点联系这步。官方在源码中的注释也说了，这一步是没有必要的，因为Iterator被回收后，双向链表中全部节点也会被回收，只是早点晚点的区别而已。

```java
/**
     * Removes all of the elements from this list.
     * The list will be empty after this call returns.
     */
    public void clear() {
        // Clearing all of the links between nodes is "unnecessary", but:
        // - helps a generational GC if the discarded nodes inhabit
        //   more than one generation
        // - is sure to free memory even if there is a reachable Iterator
        for (Node<E> x = first; x != null; ) {
            Node<E> next = x.next;
            x.item = null;
            x.next = null;
            x.prev = null;
            x = next;
        }
        first = last = null;
        size = 0;
        modCount++;
    }
```





# 三 、栈

## 3.1、栈

**栈：** 是一种操作受限，特殊的线性表，只能在一端进行操作。

* 往栈中**添加**元素的操作，一般叫做push，入栈。
* 从栈中**移除**元素的操作，一般叫做pop，出栈(只能移除栈顶元素，也叫做：弹出栈顶元素)。
* 后进先出的原则，Last In First Out，LIFO。

![1573882026188](/1573882026188.png)

**代码实现：**

```java
import com.zsd.list.ArrayList;

/**
 * @Author zhoushaodong
 * @Description 栈的顺序存储实现
 * @Date 2019/11/16 14:15
 */
public class Stack<E> {
    // 使用组合的方式 可以避免继承的方法暴露的缺点
    private ArrayList<E> list = new ArrayList<>();

    // 清空栈内的全部元素
    public void clear(){
        list.clear();
    }

    // 获取栈中元素个数
    public int size(){
        return list.size();
    }

    // 判断栈是否为空
    public boolean isEmpty(){
        return list.isEmpty();
    }

    // 入栈
    public void push(E element) {
        list.add(element);
    }

    // 出栈
    public E pop() {
        return list.remove(list.size() - 1);
    }

    // 查看栈顶元素
    public E top() {
        return list.get(list.size() - 1);
    }
}

```

`测试方法`

```java
// 测试栈
    private static void test1(){
        Stack<Integer> stack = new Stack<>();
        stack.push(11);
        stack.push(22);
        stack.push(33);
        stack.push(44);

        while (!stack.isEmpty()){
            System.out.println(stack.pop());
        }
    }
```



# 四、队列  

## 4.1、队列

**队列：** 是一种特殊的线性表，只能在头尾两端进行操作。

* 队尾(rear)：只能在队尾添加元素，一般称为enQueue，入队。
* 队头(front)：只能在队头移除元素，一般称为deQueue，出队。
* 先进先出的原则，First In First Out，FIFO。

![1573891395220](/1573891395220.png)

**代码实现：**

`Queue类`：队列的实现

```java
package com.zsd;

import com.zsd.list.LinkedList;

/**
 * @Author zhoushaodong
 * @Description 队列的链式存储实现
 * @Date 2019/11/16 16:10
 */
public class Queue<E> {

    private LinkedList<E> list = new LinkedList();

    // 请空队列内的所有元素
    public void clear() {
        list.clear();
    }

    // 获取队列内元素的个数
    public int size() {
        return list.size();
    }

    // 判断队列是否为空
    public boolean isEmpty() {
        return list.isEmpty();
    }

    // 入队
    public void enQueue(E element) {
        list.add(element);
    }

    // 出队
    public E deQueue() {
        return list.remove(0);
    }

    // 查看队头元素
    public E front(){
        return list.get(0);
    }
}
```

`测试方法`

```java
// 测试队列
    private static void test1(){
        Queue<Integer> queue = new Queue<>();
        queue.enQueue(11);
        queue.enQueue(22);
        queue.enQueue(33);
        queue.enQueue(44);
        while (!queue.isEmpty()){
            System.out.println(queue.deQueue());
        }
    }
```



## 4.2、循环队列

**循环队列：** 存放数据的数组可以循环使用还有动态扩容。

**代码实现：**

```java
package com.zsd.circle;

/**
 * @Author zhoushaodong
 * @Description 循环队列的顺序存储实现
 * @Date 2019/11/17 10:48
 */
public class CircleQueue<E> {
    private int front;
    private int size;
    private E[] elements;
	// 默认容量10
    private static final int DEFAULT_CAPACITY = 10;

    public CircleQueue() {
        elements = (E[]) new Object[DEFAULT_CAPACITY];
    }

    // 请空队列内的所有元素
    public void clear() {

    }
    
    // 获取队列内元素的个数
    public int size() {
        return size();
    }

    // 判断队列是否为空
    public boolean isEmpty() {
        return size == 0;
    }
    
    // 入队
    public void enQueue(E element) {
        ensureCapacity(size + 1);
        // (front+size)%elements.length可以找到最后一个要添加位置的索引
        elements[index(size)] = element;
        size++;
    }

    // 出队
    public E deQueue() {
        E frontElement = elements[front];
        elements[front] = null;
        // 找到下一个正确的头元素索引
        front = index(1);
        size--;
        return frontElement;
    }

    // 查看队头元素
    public E front() {
        return elements[front];
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("capacity = " + elements.length).
                append(" size = " + size).
                append(" front= " + front).
                append(" ,[");
        for (int i = 0; i < elements.length; i++) {
            if (i != 0) sb.append(",");
            sb.append(elements[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    /**
     * 计算出该索引在真实数组的索引
     *
     * @param index
     * @return
     */
    private int index(int index) {
        return (front + index) % elements.length;
    }

    /**
     * 保证容量有capacity
     *
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        // 新容量为旧容量的1.5倍
        // >>1 代表右移1位 可以理解为除以2
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E newElements[] = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[index(i)];
        }
        elements = newElements;
        // 重置front
        front = 0;
        System.out.println(oldCapacity + " 扩容为 " + newCapacity);
    }
}
```

`测试方法`

```java
// 测试循环队列
    private static void test3(){
        CircleQueue<Integer> queue = new CircleQueue<>();
        for (int i = 0; i < 10 ; i++) {
            queue.enQueue(i);
        } // [0,1,2,3,4,5,6,7,8,9]
        System.out.println(queue);
        for (int i = 0; i < 5 ; i++) {
            queue.deQueue();
        } // [5,6,7,8,9]
        System.out.println(queue);
        for (int i = 15; i <23 ; i++) {
            queue.enQueue(i);
        }
        System.out.println(queue);
        while (!queue.isEmpty()){
            System.out.println(queue.deQueue());
        }
    }
```





## 4.2、双端队列

**双端队列：** 可以在头尾两端进行**添加**、**删除**、**查看** 操作的队列。

**代码实现：**

`Deque类`：双端队列的链式实现

```java
package com.zsd;

import com.zsd.list.LinkedList;

/**
 * @Author zhoushaodong
 * @Description 使用双向链表实现双端队列
 * @Date 2019/11/16 19:15
 */
public class Deque<E> {
    private LinkedList<E> list = new LinkedList();

    // 请空队列内的所有元素
    public void clear() {
        list.clear();
    }

    // 获取队列内元素的个数
    public int size() {
        return list.size();
    }

    // 判断队列是否为空
    public boolean isEmpty() {
        return list.isEmpty();
    }


    /**
     * 队头入队
     * @param element
     */
    public void enQueueFront(E element){
        list.add(0,element);
    }

    /**
     * 队尾入队
     * @param element
     */
    public void enQueueRear(E element){
        list.add(element);
    }

    // 队头出队
    public E deQueueFront(){
        return list.remove(0);
    }

    // 队尾出队
    public E deQueueRear(){
        return list.remove(list.size()-1);
    }

    // 获取队头的元素
    public E front(){
        return list.get(0);
    }

    // 获取队尾的元素
    public E rear(){
        return list.get(list.size()-1);
    }
    
}
```

`测试方法`

```java
// 测试双端队列
    private static void test2(){
        Deque<Integer> de = new Deque<>();
        de.enQueueFront(11);
        de.enQueueFront(22);
        de.enQueueRear(33);
        de.enQueueRear(44); // [ 44 33 11 22]
        System.out.println(de.front());
        System.out.println(de.rear());

        while (!de.isEmpty()){
            System.out.println(de.deQueueFront());
        }
    }
```



## 4.3、循环双端队列

**循环双端队列：** 可以在头尾两端进行**添加**、**删除**、**查看** 操作的队列，并且数组内空间循环使用，不浪费数组空间。

**代码实现：**

`CircleDeque类`：循环双端队列的顺序存储实现

```java
package com.zsd.circle;

import com.zsd.list.LinkedList;

/**
 * @Author zhoushaodong
 * @Description 循环双端队列的顺序存储实现
 * @Date 2019/11/19 16:27
 */
public class CircleDeque<E> {
    private int front;
    private int size;
    private E[] elements;


    private static final int DEFAULT_CAPACITY = 10;

    public CircleDeque() {
        elements = (E[]) new Object[DEFAULT_CAPACITY];
    }

    // 请空队列内的所有元素
    public void clear() {
        for (int i = 0; i < size; i++) {
            // 因为使用了泛型，泛型只能存引用类型的对象，Object[]中存取的是对象的地址值
            // 所以清空的时候把每个元素地址值指向的对象释放掉，而不是销毁整个数组，数组可以留下循环利用。
            elements[index(i)] = null;
        }
        size = 0;
        front = 0;
    }

    // 获取队列内元素的个数
    public int size() {
        return size();
    }

    // 判断队列是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 队头入队
     *
     * @param element
     */
    public void enQueueFront(E element) {
        ensureCapacity(size + 1);

        front = index(-1);
        elements[front] = element;
        size++;
    }

    /**
     * 队尾入队
     *
     * @param element
     */
    public void enQueueRear(E element) {
        ensureCapacity(size + 1);

        elements[index(size)] = element;
        size++;
    }

    // 队头出队
    public E deQueueFront() {
        E frontElement = elements[front];
        elements[front] = null;
        front = index(1);
        size--;
        return frontElement;
    }

    // 队尾出队
    public E deQueueRear() {
        int rearIndex = index(size - 1);
        E rearElement = elements[rearIndex];
        elements[rearIndex] = null;
        size--;
        return rearElement;
    }

    // 获取队头的元素
    public E front() {
        return elements[front];
    }

    // 获取队尾的元素
    public E rear() {

        return elements[index(size - 1)];
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("capacity = " + elements.length).
                append(" size = " + size).
                append(" front= " + front).
                append(" ,[");
        for (int i = 0; i < elements.length; i++) {
            if (i != 0) sb.append(",");
            sb.append(elements[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    /**
     * 计算出该索引在真实数组的索引
     *
     * @param index
     * @return
     */
    private int index(int index) {
        index += front;
        if (index < 0) {
            return index + elements.length;
        }
        return index - (index >= elements.length ? elements.length : 0);
    }

    /**
     * 保证容量有capacity
     *
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        // 新容量为旧容量的1.5倍
        // >>1 代表右移1位 可以理解为除以2
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E newElements[] = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[index(i)];
        }
        elements = newElements;
        // 重置front
        front = 0;
        System.out.println(oldCapacity + " 扩容为 " + newCapacity);
    }
}
```

`测试方法`

```java
// 测试循环双端队列
    private static void test4() {
        CircleDeque<Integer> de = new CircleDeque<>();
        // [8 7 6 5 4 3 2 1 100 101 102 103 104 105 106 107 108 109 null null 10 9]
        for (int i = 0; i < 10; i++) {
            de.enQueueFront(i+1);
            de.enQueueRear(i+100);
        }
        System.out.println(de);

        // [null 7 6 5 4 3 2 1 100 101 102 103 104 105 106 null null null null null null null]
        for (int i = 0; i < 3; i++) {
            de.deQueueFront();
            de.deQueueRear();
        }
        System.out.println(de);

        // [11 7 6 5 4 3 2 1 100 101 102 103 104 105 106 null null null null null null 12]
        de.enQueueFront(11);
        de.enQueueFront(12);

        while (!de.isEmpty()){
            System.out.println(de.deQueueFront());
        }
    }
```

## 4.4、%运算符优化

我们在编程中，尽量避免使用**乘***、**除/**、**模%**，**浮点数**运算。

我们改成使用**加+**、**减-**运算，会有一个小优化。

```java
// CircleQueue(循环队列)中对取模运算的优化
private int index(int index) {
        //return (front + index) % elements.length;

        // 索引index+front是小于element.length的2倍，且index>0
        index += front;
        return index - (index >= elements.length ? elements.length : 0);
	}

// CircleDeque(循环双端队列)中对取模运算的优化
private int index(int index) {
        index += front;
        if (index < 0) {
            return index + elements.length;
        }
        //return index % elements.length;
        return index - (index >= elements.length ? elements.length : 0);
    }
```

* 已知n>=0，m>0
* **n%m**等价于**n- (m > n ? 0 : m)**的前提条件是：**n < 2m**

# 五、树

## 5.1 树的定义与性质

**树：** 树是有至少0个节点构成的集合。0个节点的树称为空树。1个节点的树，只有1个根节点。

**节点的度： ** 子树的个数。

**树的度：** 所有节点的度中的最大值。

**叶子节点：** 度为0的节点。

**非叶子节点：** 度不为0的节点。

**层数：** 根节点为第1层，根节点的子节点为第2层。(有些书籍定义根节点为第0层)

**节点的深度：** 从根节点到当前节点的唯一路径的节点总数。

**节点的高度：** 从根节点到最远叶子节点的节点总数。

**树的深度：** 所有节点深度中的最大值。

**树的高度：** 所有节点中深度的最大值。

**ps：** 树的深度等于树的高。

**有序树：** 树中的任意一个节点的个孩子节点有严格排列次序的树。

**无序树：** 树中任意一个节点的各孩子节点之间的次序无紧要的树。

## 5.2、二叉树的定义和性质

**二叉树：** 是由n（n>=0）个有限的节点构成的集合。每个节点的度最大为2。

**性质1：** 非空二叉树的第i层，最多有2<sup>i-1</sup>个节点（i>=1）。

**性质2：** 在高度为h的二叉树最多有2<sup>h-1</sup>个节点（h>=1）。

**性质3：** 对于一棵非空的二叉树，如果节点个数为n<sub>0</sub>,度为2的节点数为n<sub>2</sub>,则有n<sub>0</sub> = n<sub>2</sub>+1。

假设度为1的节点个数为n<sub>1</sub>，那么二叉树的节点总数为n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>

另外，二叉树中除了根节点，每个节点都有指向它的边，二叉树的总边数为T=n-1。

从二叉树的结构可以知道，二叉树的边数是由度为1和度为2的节点发出的，每个度为1的节点发出一条边数，每个度为2的节点发出两条边，所以有：T=n<sub>1</sub>+2n<sub>2</sub>

则有T=n<sub>1</sub>+2n<sub>2</sub> =n-1=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>-1,得出n<sub>0</sub> = n<sub>2</sub>+1。

**满二叉树：** 所有节点的度要么为0，要么为2，且所有叶子节点都在最后一层。

**性质1：** 假设二叉树的高度为h（h>=1），那么

* 第i层的节点数量：2<sup>i-1</sup>

* 叶子节点数量：2<sup>h-1</sup>	

* 总节点数量：n=2<sup>h</sup>-1

**ps：** 在同样高度的二叉树中，满二叉树的叶子节点数量最多，总节点数量最多。

**完全二叉树：** 如果一棵具有n个节点的二叉树的结构与满二叉树的前n个节点的结构相同。

**性质1：** 度为1的节点只有左子树。

**性质2：** 度为1的节点要么是1个，要么是0个。

**性质3：** 同样节点数量的二叉树，完全二叉树的高度是最小的。

**性质4：** 假设完全二叉树的高度为h（h>=1）,那么

* 至少有2<sup>h-1</sup>个节点（2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>+..+2<sup>h-2</sup>+1）。

* 至多有2<sup>h-1</sup>个节点(相当于满二叉树)。

* 总节点数量为n，高度h = floor(log<sub>2</sub>n)+1（floor是向下取整函数）。

**性质5：** 一棵有n个节点的完全二叉树（n>0），从上到下，从左到右对节点从1开始编号，对第i个节点，

* 如果i=1，它是根节点
* 如果i>1，它的父节点编号为floor(i/2)
* 如果2i<=n，它的左子节点编号为2i
* 如果2i>n，它无左子节点
* 如果2i+1<=n，它的有子节点编号为2i+1
* 如果2i+1>n，它无右子节点

**性质6：** 一棵有n个节点的完全二叉树（n>0），从上到下，从左到右对节点从0开始编号，对第i个节点，

* 如果i=0，它是根节点
* 如果i>0，它的父节点编号为floor((i-1)/2)
* 如果2i+1<=n-1，它的左子节点编号为2i+1
* 如果2i+1>n-1，它无左子节点
* 如果2i+2<=n-1，它的有子节点编号为2i+2
* 如果2i+2>n-1，它无右子节点

**ps：** 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。

## 5.3、二叉搜索树

**二叉搜索树：** 是二叉树的一种，是应用非常广泛的二叉树，英文叫Binary Search Tree，简称为BST。

* 又被称为：二叉查找树，二叉排序树。

* 任意一个节点的值都大于其左子树所有节点的值。
* 任意一个节点的值都小于其右子树所有节点的值。
* 二叉搜索树可以大大提高搜索数据的效率。

![1573097012470](/1573097012470.png)

**代码实现：**

`Person类`

```java
public class Person implements Comparable<Person> {
    private int age;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person(int age) {
        this.age = age;
    }

    @Override
    public int compareTo(Person e) {
        return this.age - e.age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                '}';
    }
}
```

`BinarySearchTree类`：二叉搜索树

```java
package com.zsd;

import com.zsd.printer.BinaryTreeInfo;

import java.util.Comparator;
import java.util.LinkedList;
import java.util.Queue;

public class BinarySearchTree<E> implements BinaryTreeInfo {
    private int size;
    private Node<E> root;
    private Comparator<E> comparator;

    public BinarySearchTree() {
        this(null);
    }

    public BinarySearchTree(Comparator<E> comparator) {
        this.comparator = comparator;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public void clear() {

    }

    public void add(E element) {
        elementNotNullCheck(element);
        // 添加第一个节点 即根节点
        if (root == null) {
            root = new Node<>(element, null);
            size++;
        }
        // 添加的不是第一个节点
        // 找到父节点
        Node<E> parent = null;
        Node<E> node = root;
        // 把方向存起来
        int cmp = 0;
        while (node != null) {
            cmp = compare(element, node.element);
            parent = node;
            if (cmp > 0) {
                node = node.right;
            } else if (cmp < 0) {
                node = node.left;
            } else {
                // 相等
                // 新的节点覆盖旧的节点
                node.element = element;
                return;
            }
        }

        // 看看要插入到父节点的左边还是右边
        Node<E> newNode = new Node<>(element, parent);
        if (cmp > 0) {
            parent.right = newNode;
        } else {
            parent.left = newNode;
        }
        size++;
    }

    public void remove(E element) {

    }

    public boolean contains(E element) {
        return false;
    }

    public void elementNotNullCheck(E element) {
        if (element == null) {
            throw new IllegalArgumentException("element must not be null");
        }
    }


    /**
     * @return 如果e1等于e2，返回0；如果e1大于e2，返回值大于0；如果e1小于e2，返回值小于0；
     */
    private int compare(E e1, E e2) {
        if (comparator != null) {
            return comparator.compare(e1, e2);
        }
        return ((Comparable<E>) e1).compareTo(e2);
    }

    /*
    // 前序遍历的外部访问
    public void preorderTraversal() {
        preorderTraversal(root);
    }

    // 前序遍历
    private void preorderTraversal(Node<E> node) {
        if (node == null) return;
        // 打印当前访问的节点
        System.out.println(node.element);
        // 遍历左子树
        preorderTraversal(node.left);
        // 遍历右子树
        preorderTraversal(node.right);
    }

    // 中序遍历的外部访问
    public void inorderTraversal() {
        inorderTraversal(root);
    }

    // 中序遍历
    private void inorderTraversal(Node<E> node) {
        if (node == null) return;
        // 遍历左子树
        inorderTraversal(node.left);
        // 打印当前访问的节点
        System.out.println(node.element);
        // 遍历右子树
        inorderTraversal(node.right);
    }

    // 后序遍历的外部访问
    public void postTraversal() {
        postTraversal(root);
    }

    // 后序遍历
    private void postTraversal(Node<E> node) {
        if (node == null) return;
        // 遍历左子树
        postTraversal(node.left);
        // 遍历右子树
        postTraversal(node.right);
        // 打印当前访问的节点
        System.out.println(node.element);
    }

    // 层序遍历
    public void orderTraversal() {
        if (root == null) return;
        Queue<Node<E>> queue = new LinkedList<>();
        // 入队
        queue.offer(root);
        while(!queue.isEmpty()){
            // 出队
            Node<E> node = queue.poll();
            System.out.println(node.element);
            // 左子树不为null就入队
            if(node.left!=null){
                queue.offer(node.left);
            }
            // 右子树不为null就入队
            if(node.right!=null){
                queue.offer(node.right);
            }
        }
    }
    */





    // 前序遍历
    public void preorder(Visitor<E> visitor) {
        preorder(root,visitor);
    }

    private void preorder(Node<E> node, Visitor<E> visitor) {
        if (root == null || visitor == null) return;
        // 传入遍历逻辑方法
        visitor.visit(node.element);
        // 遍历左子树
        preorder(node.left,visitor);
        // 遍历右子树
        preorder(node.right,visitor);
    }

    // 中序遍历
    public void inorder(Visitor<E> visitor){
        inorder(root,visitor);
    }

    private void inorder(Node<E> node,Visitor<E> visitor){
        if (root == null || visitor == null) return;
        // 遍历左子树
        inorder(node.left,visitor);
        // 传入遍历逻辑方法
        visitor.visit(node.element);
        // 遍历右子树
        inorder(node.right,visitor);
    }

    // 后序遍历
    public void postorder(Visitor<E> visitor){
        postorder(root,visitor);
    }

    private void postorder(Node<E> node,Visitor<E> visitor){
        if (root == null || visitor == null) return;
        // 遍历左子树
        postorder(node.left,visitor);
        // 遍历右子树
        postorder(node.right,visitor);
        // 传入遍历逻辑方法
        visitor.visit(node.element);
    }

    // 层序遍历
    public void orderTraversal(Visitor<E> visitor) {
        if (root == null || visitor == null) return;
        Queue<Node<E>> queue = new LinkedList<>();
        // 入队
        queue.offer(root);
        while (!queue.isEmpty()) {
            // 出队
            Node<E> node = queue.poll();
            // 传入遍历逻辑方法
            visitor.visit(node.element);
            // 左子树不为null就入队
            if (node.left != null) {
                queue.offer(node.left);
            }
            // 右子树不为null就入队
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }


    @Override
    public Object root() {
        return root;
    }

    @Override
    public Object left(Object node) {
        return ((Node<E>) node).left;
    }

    @Override
    public Object right(Object node) {
        return ((Node<E>) node).right;
    }

    @Override
    public Object string(Object node) {
        return ((Node<E>) node).element;
    }

    public static interface Visitor<E> {
        void visit(E element);
    }

    private static class Node<E> {
        E element;
        Node<E> left;
        Node<E> right;
        Node<E> parent;

        public Node(E element, Node<E> parent) {
            this.element = element;
            this.parent = parent;
        }
    }
}

```



`Main类 `：测试类

```java
import java.util.Comparator;

public class Main {
    private static class PersonComparator implements Comparator<Person> {

        @Override
        public int compare(Person e1, Person e2) {
            return e1.getAge() - e2.getAge();
        }
    }

    private static class PersonComparator2 implements Comparator<Person> {

        @Override
        public int compare(Person e1, Person e2) {
            return e2.getAge() - e1.getAge();
        }
    }

    // 测试Integer数组的二叉搜索树
    private static void test1(){
        BinarySearchTree<Integer> bst1 = new BinarySearchTree();
        Integer data[] = new Integer[]{7,4,9,2,5,8,11,3,12,1};
        for (int i = 0; i < data.length; i++) {
            bst1.add(data[i]);
        }

        BinaryTrees.print(bst1);
    }

    // 测试自定义的比较器二叉搜索树
    private static void test2(){
        Integer data[] = new Integer[]{7,4,9,2,5,8,11,3,12,1};
        // 传入比较器比较
        BinarySearchTree<Person> bst1 = new BinarySearchTree(new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o2.getAge()-o1.getAge();
            }
        });

        for (int i = 0; i < data.length; i++) {
            bst1.add(new Person(data[i]));
        }
        BinaryTrees.println(bst1);
    }

    // 测试写入文件
    private static void test3(){
        BinarySearchTree<Integer> bst1 = new BinarySearchTree();
        Integer data[] = new Integer[]{7,4,9,2,5,8,11,3,12,1};
        for (int i = 0; i < data.length; i++) {
            bst1.add(data[i]);
        }
        Files.writeToFile("./tree.txt",BinaryTrees.printString(bst1));
    }

    // 测试比较值相等，就覆盖
    private static void test4(){
        BinarySearchTree<Person> bst1 = new BinarySearchTree();
        bst1.add(new Person(12,"zhangsan"));
        bst1.add(new Person(15,"lisi"));
        bst1.add(new Person(18,"wangwu"));
        bst1.add(new Person(15,"zhaoliu"));
        bst1.add(new Person(10,"wangba"));
        BinaryTrees.println(bst1);
    }

    public static void main(String[] args) {
        test1();
        System.out.println();
        test2();
        test3();
        System.out.println();
        test4();
    }
}
```

 

`输出结果`

![1573289114118](/1573289114118.png)



![1573285446138](/1573285446138.png)

## 5.4、二叉树的遍历

根据根节点访问顺序的不同，二叉树的常见遍历方式有4种：

* 前序遍历(Preorder Traversal)：先访问根节点、再访问左子树，再访问右子树。下图二叉树前序遍历的顺序为：7、4、2、1、3 、5 、9、8、11、10、12 

**代码实现：**

```java
// 前序遍历的外部访问
public void preorderTraversal() {
    preorderTraversal(root);
}

// 前序遍历
private void preorderTraversal(Node<E> node) {
    if (node == null) return;
    // 打印当前访问的节点
    System.out.println(node.element);
    // 遍历左子树
    preorderTraversal(node.left);
    // 遍历右子树
    preorderTraversal(node.right);
}
```



* 中序遍历(Inorder Traversal)：中序遍历因为只要第二个访问根节点就行，所有就有先访问左子树还是右子树两种。

  1. 先访问左子树，再访问根节点，再访问有右子树。下图二叉树中序遍历的顺序为：1、2、3、4、5、7、8、9、10、11、12

  2. 先访问右子树，再访问根节点，再访问有左子树。下图二叉树中序遍历的顺序为：12、11、10、9、8、7、5、4、3、2、1

  3. 根据前两点可以知道，二叉搜索树的遍历的结果是升序或者降序的。

**代码实现：**

```java
// 中序遍历的外部访问
public void inorderTraversal(){
    inorderTraversal(root);
}

// 中序遍历
private void inorderTraversal(Node<E> node) {
    if (node == null) return;
    // 遍历左子树
    inorderTraversal(node.left);
    // 打印当前访问的节点
    System.out.println(node.element);
    // 遍历右子树
    inorderTraversal(node.right);
}
```



* 后序遍历(Postorder Traversal)：先访问左子树，再访问右子树，再访问有根节点。下图二叉树后序遍历的顺序为：1、3、2、5、4、8、10、12、11、9、7

**代码实现：**

```java
// 后序遍历的外部访问
public void postTraversal(){
    postTraversal(root);
}

// 后序遍历
private void postTraversal(Node<E> node) {
    if (node == null) return;
    // 遍历左子树
    postTraversal(node.left);
    // 遍历右子树
    postTraversal(node.right);
    // 打印当前访问的节点
    System.out.println(node.element);
}
```



* 层序遍历(Level Order Traversal)：从上到下，从左到右依次访问每一个节点。

**代码实现：**



![1573289991207](/1573289991207.png)



5.5、二叉树遍历

# 六、图













